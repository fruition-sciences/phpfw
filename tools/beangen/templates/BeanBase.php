global $descriptor;
echo "<" . "?php";
?>

/*
 * Do not edit this file.
 * This code was automatically generated.
<?php if ($descriptor->xml->description) { ?>
 *
 * <?php echo wordwrap(trim(preg_replace("/\s+/", " ", $descriptor->xml->description)), 77, "\n * ") ?> 
<?php } ?>
 * 
 * Generated on <?php echo date("F j, Y") ?> 
 */

abstract class <?php echo $descriptor->xml['name'] ?>BeanBase extends BeanBase {
    const TABLE_NAME = "<?php echo $descriptor->xml['tableName'] ?>";

<?php if (sizeof($descriptor->xml->constant) > 0) { ?>
    // Constants
<?php     foreach ($descriptor->xml->constant as $constant) { ?>
<?php         if ($constant['comment'] && strlen(trim($constant['comment'])) > 0) { ?>
    /**
     * <?php echo wordwrap($constant['comment'], 73, "\n     * ") ?>.
     */
<?php         } ?>
    const <?php echo $constant['name'] ?> = <?php echo $constant['id'] ?>;

<?php     } ?>
<?php } ?>
    // Columns
<?php
  foreach ($descriptor->xml->field as $field) {
?>
    const <?php echo $descriptor->fieldConstant($field) ?> = "<?php echo $field['column'] ?>";
<?php
  }
?>

    // All columns
    public static $ALL = array(<?php
  $started = false;
  foreach ($descriptor->xml->field as $field) {
    if ($started) {
        echo ", ";
    }
    echo "self::" . $descriptor->fieldConstant($field);
    $started = true;
  }
?>);

    // SQL Function for each of the columns. This is needed when there are fields of type 'GeomPoint' or 'GeomPolygon'.
    public static $functions = array(<?php
  $started = false;
  foreach ($descriptor->xml->field as $field) {
    if ($started) {
        echo ", ";
    }
     if ($field['type'] == "GeomPoint" || $field['type'] == "GeomPolygon" ) {
       echo '"AsText"';   
     }else{
        echo "null"; 
     }
    
    $started = true;
  }
  ?>);

    // Fields
<?php
  foreach ($descriptor->xml->field as $field) {
?>
    private $<?php 
      echo $field['name'];
      $defaultValue = null;
      if ($field['type'] == "id") {
          $defaultValue = -1;
      }
      if (isset($field['defaultValue'])) {
          $defaultValue = $field['defaultValue'];
      }
      if ($defaultValue !== null) {
          echo " = $defaultValue";
      }
      ?>;
<?php
 }
 ?>
 
    /**
     * Map containing the original values, as loaded from DB. Allows checking if
     * any field has changed. Keys are the column names.
     *
     * @var Array
     */
    private $prevValues = array();
 <?php

  // Declare relationships (skips relationship to constant tables)
  $declaredRelationships = array();
  foreach ($descriptor->xml->relationship as $rel) {
      // Skip 1:1 relationship to a constant table
      if ($rel['type'] == 'one-to-one' && $rel['isConstant']) {
          continue;
      }
      $declaredRelationships[] = $rel;
  }
  if ($declaredRelationships) {
?>

    // Relationships
<?php
      foreach ($declaredRelationships as $rel) {
?>
    private $<?php echo $rel['name']?>;
<?php
      }
  }
?>

<?php
  foreach ($descriptor->xml->field as $field) {
      $comment = "";
      if ($field["comment"]) {
          $comment = $field["comment"];
      }
      if ($field['unit']) {
          $unitInfo = preg_split('/::/', $field["unit"]);
          $unitClassName = $unitInfo[0];
          $unitConstantName = $unitInfo[1];
          $comment .= " ($unitConstantName)";
      }
?>
    /**
<?php if ($comment) { ?>
     * <?php echo wordwrap($comment, 73, "\n     * ") ?>.
     * 
<?php } ?>
     * @return <?php echo $field['type']?> 
<?php if ($field["deprecateReason"]) { ?>
     * @deprecated <?php echo wordwrap($field["deprecateReason"], 73, "\n     * ") ?>.
<?php } ?>
     */
    public function <?php echo $descriptor->getterName($field) ?>() {
        return $this-><?php echo $field['name']?>;
    }

    /**
     * Get the value of the '<?php echo $field['name']?>' field, as it was when loaded from the DB.
     *
     * @return id or null if this is a new bean.
     */
    public function <?php echo $descriptor->getterName($field) ?>Was() {
        if (isset($this->prevValues[self::<?php echo $descriptor->fieldConstant($field) ?>])) {
            return $this->prevValues[self::<?php echo $descriptor->fieldConstant($field) ?>];
        }
        return null;
    }

    /**
     * Check if the '<?php echo $field['name']?>' field has changed since it was loaded from the DB.
     *
     * @return boolean
     */
    public function <?php echo $descriptor->isChangedName($field) ?>() {
        return $this-><?php echo $descriptor->getterName($field) ?>() != $this-><?php echo $descriptor->getterName($field) ?>Was();
    }

    /**
<?php if ($comment) { ?>
     * <?php echo wordwrap($comment, 73, "\n     * ") ?>.
     *
<?php } ?>
     * @param <?php echo $field['type']?> $<?php echo $field["name"]?> 
<?php if ($field["deprecateReason"]) { ?>
     * @deprecated <?php echo wordwrap($field["deprecateReason"], 73, "\n     * ") ?>.
<?php } ?>
     */
    public function <?php echo $descriptor->setterName($field) ?>($<?php echo $field["name"]?>) {
<?php
  if ($field["type"] == "Boolean") {
?>
        $this-><?php echo $field["name"]?> = ($<?php echo $field["name"]?> != null && $<?php echo $field["name"]?> != 0 && $<?php echo $field["name"]?> != false);
<?php
  }
  else{
?>
        $this-><?php echo $field["name"]?> = $<?php echo $field["name"]?>;
<?php
  }
  $fieldName = $field["name"];
    if (isset($descriptor->oneToOneRelsMap["${fieldName}"])) {
      $rel = $descriptor->oneToOneRelsMap["${fieldName}"];
      if (!$rel['isConstant']) {
?>
        // If id doesn't match the id of '<?php echo $rel["name"]?>', set '<?php echo $rel["name"]?>' to null
        if (isset($this-><?php echo $rel['name']?>) && $this-><?php echo $rel['name']?>->getId() != $<?php echo $field["name"]?>) {
            $this-><?php echo $rel["name"]?> = null;
        }
<?php
      }
    }
?>
    }
<?php 
  if ($field["unit"]) {
      $measureParamName = $field["name"] . 'Measure';
?>

    /**
     * <?php echo wordwrap("Get the " . $field["name"] . " as a Zend Measure object, containing both the unit measure and the value", 73, "\n     * ") ?>.
     *
     * @return <?php echo $unitInfo[0] ?> 
<?php if ($field["deprecateReason"]) { ?>
     * @deprecated <?php echo wordwrap($field["deprecateReason"], 73, "\n     * ") ?>.
<?php } ?>
     */
    public function <?php echo $descriptor->unitGetterName($field) ?>() {
        return new <?php echo $unitClassName ?>($this-><?php echo $descriptor->getterName($field) ?>(), <?php echo $field["unit"] ?>);
    }

    /**
     * <?php echo wordwrap("Set the {$field["name"]} using a Zend Measure object. The unit can be any $unitClassName unit. It will automatically be converted to $unitConstantName", 73, "\n     * ") ?>.
     * 
     * @param $<?php echo $field["name"]?>Measure <?php echo $unitClassName ?> 
<?php if ($field["deprecateReason"]) { ?>
     * @deprecated <?php echo wordwrap($field["deprecateReason"], 73, "\n     * ") ?>.
<?php } ?>
     */
    public function <?php echo $descriptor->unitSetterName($field) ?>($<?php echo $measureParamName?>) {
        if (!$<?php echo $measureParamName?>) {
        	$this-><?php echo $descriptor->setterName($field) ?>(null);
        	return;
        }
        // If the unit is the same, just set the value
        if ($<?php echo $measureParamName?>->getType() == <?php echo $field["unit"] ?>) {
            $this-><?php echo $descriptor->setterName($field) ?>($<?php echo $measureParamName?>->getValue());
            return;
        }
        // Otherwise, clone the given measure (to avoid modifying it)
        $clonedMeasure = new <?php echo $unitClassName ?>($<?php echo $measureParamName?>->getValue(), $<?php echo $measureParamName?>->getType(), $<?php echo $measureParamName?>->getLocale());
        // Convert to <?php echo $unitConstantName ?> 
        $clonedMeasure->setType(<?php echo $field["unit"] ?>);
        $this-><?php echo $descriptor->setterName($field) ?>($clonedMeasure->getValue());
    }
<?php
  } // $field["unit"]
?>

<?php
    if (isset($descriptor->oneToOneRelsMap["${fieldName}"])) {
      $rel = $descriptor->oneToOneRelsMap["${fieldName}"];
      if ($rel['isConstant']) {
?>
    /**
     * <?php echo wordwrap("Get the relationship field '" . $rel["name"] . "'. This is a reference to a constant table", 73, "\n     * ") ?>.
     *
     * @return <?php echo $rel["refType"]?> 
     */
    public function <?php echo $descriptor->getterName($rel) ?>() {
        return <?php echo $rel["refType"]?>Home::get($this-><?php echo $rel["foreignKey"]?>);
    }

<?php
      }
      else {
?>
    /**
     * Get the relationship field '<?php echo $rel["name"]?>'.
     *
     * @return <?php echo $rel["refType"]?> 
     */
    public function <?php echo $descriptor->getterName($rel) ?>() {
        return $this-><?php echo $rel["name"]?>;
    }

    /**
     * Set the relationship field '<?php echo $rel["name"]?>'.
     * This also sets the field <?php echo $rel["foreignKey"]?> according to its primary key.
     *
     * @param <?php echo $rel["refType"]?> $<?php echo $rel["name"]?> 
     */
    public function <?php echo $descriptor->setterName($rel) ?>($<?php echo $rel["name"]?>) {
        $this-><?php echo $rel["name"]?> = $<?php echo $rel["name"]?>;
        $this-><?php echo $rel["foreignKey"]?> = ($<?php echo $rel["name"]?>) ? $<?php echo $rel["name"]?>->getId() : -1;
    }

    /**
     * Load the relationship field '<?php echo $rel["name"]?>' if it's not loaded yet.
     *
     * @return <?php echo $rel["refType"]?> 
     */
    public function <?php echo $descriptor->loaderName($rel) ?>() {
        if (!$this-><?php echo $rel["name"]?> && $this-><?php echo $rel["foreignKey"]?> > 0) {
            $this-><?php echo $rel["name"]?> = <?php echo $rel["refType"]?>Home::find($this-><?php echo $rel["foreignKey"]?>);
        }
        return $this-><?php echo $rel["name"]?>;
    }

<?php
      }
    }
  }

  foreach ($descriptor->oneToManyRelsList as $rel) {
?>

    /**
     * Get the content of the <?php echo $rel['name']?> relationship field.
     *
     * @return List of <?php echo $rel['refType']?> objects.
     */
    public function <?php echo $descriptor->getterName($rel)?>() {
        return $this-><?php echo $rel['name']?>;
    }

    /**
     * Set the the <?php echo $rel['name']?> relationship field.
     *
     * @param Array (of <?php echo $rel['refType']?> objects) $list
     */
    public function <?php echo $descriptor->setterName($rel)?>($list) {
        $this-><?php echo $rel['name']?> = $list;
    }

    /**
     * Add a new <?php echo $rel['refType']?> object to the <?php echo $rel['name']?> relationship field.
     * Creates the array if it's not yet initialized.
     *
     * @param <?php echo $rel['refType']?> $bean the bean to add.
     */
    public function <?php echo $descriptor->adderName($rel)?>($bean) {
        if (!isset($this-><?php echo $rel['name']?>)) {
            $this-><?php echo $rel['name']?> = array();
        }
        $this-><?php echo $rel['name']?>[] = $bean;
    }

<?php
  }
?>
<?php
  if (sizeof($descriptor->xml->constant) > 0) {
?>
    /**
     * Get the localized label of this constant bean.
     */
    public function getLabel() {
        $key = strtoupper(self::TABLE_NAME) . '_' . $this->constantName;
        $label = I18nUtil::lookup("constants", $key)->__toString();
        return $label;
    }

<?php
  }
?>
    /**
     * Check if the value of any field of this bean has changed since it was
     * loaded from the database.
     * This is done by comparing each field with its previous value. Previous
     * values have been set by calling populatePrevValues(), which is called by
     * <?php echo $descriptor->xml['name'] ?>BeanHomeBase::populate().
     *
     * @return boolean
     */
    public function isChanged() {
<?php
  $parts = array();
  foreach ($descriptor->xml->field as $field) {
      $parts[] = '$this->' . $descriptor->isChangedName($field) . "()";
  }
?>
        return
            <?php echo implode(" ||\n            ", $parts) ?>;
    }

    /**
     * Populate the 'prevValues' map, with the values of all fields of this bean.
     * This method is being called after populating this bean.
     */
    public function populatePrevValues() {
<?php
  foreach ($descriptor->xml->field as $field) {
?>
        $this->prevValues[self::<?php echo $descriptor->fieldConstant($field) ?>] = $this-><?php echo $descriptor->getterName($field) ?>();
<?php
  }
?>
    }

    public function insert() {
        $db = Transaction::getInstance()->getDB();
        $this->createDate = time();
        $this->createUserId = Transaction::getInstance()->getUser()->getId();
        $sql = "insert into " . self::TABLE_NAME .
            " (" .
<?php
  for ($i=1; $i<sizeof($descriptor->xml->field); $i++) {
      $field = $descriptor->xml->field[$i];
      $sep = $i < sizeof($descriptor->xml->field)-1 ? "\", \"" : "\")\"";
?>
            self::<?php echo $descriptor->fieldConstant($field) . " . " . $sep;?> .
<?php
  }
?>
            " values (" .
<?php
  for ($i=1; $i<sizeof($descriptor->xml->field); $i++) {
      $field = $descriptor->xml->field[$i];
      $sep = $i < sizeof($descriptor->xml->field)-1 ? "\",\" ." : "\")\";";
?>
            <?php echo $descriptor->escapedField($field) . " . " . $sep?>

<?php
  }
?>

        $db->query($sql);
        $this->id = $db->get_last_id();
    }

    public function update() {
        $db = Transaction::getInstance()->getDB();
        $this->modDate = time();
        $this->modUserId = Transaction::getInstance()->getUser()->getId();
        $sql = "update " . self::TABLE_NAME . " set " .
<?php
  for ($i=1; $i<sizeof($descriptor->xml->field); $i++) {
      $field = $descriptor->xml->field[$i];
      $sep = $i < sizeof($descriptor->xml->field)-1 ? "\",\" ." : "";
      ?>
      
      self::<?php echo $descriptor->fieldConstant($field)?> . " = " . <?php echo $descriptor->escapedField($field) . " . $sep"?>
    <?php  }
?>
            " where " . self::ID . "=" . $this->id;
        $db->query($sql);
    }

    /**
     * Insert or update this bean, depending on whether it's new or not.
     */
    public function store() {
        if ($this->getId() > 0) {
            $this->update();
        }
        else {
            $this->insert();
        }
    }

    public function remove() {
        $db = Transaction::getInstance()->getDB();
        $sql = "delete from " . self::TABLE_NAME .
            " where " . self::ID . "=" . $this->id;
        $db->query($sql);
    }

    /**
     * Get a map containing all fields of this bean as formatted strings.
     * 
     * The strings will be formatted according to the current user's timezone
     * and locale.
     * 
     * @param Boolean $dateTime If true, date fields will be formatted as date time.
     * @param Boolean $expanded If true, more complex data types will be expanded
     *        into more than 1 parameter. The extra parameters would have a name
     *        similar to the original parameter name + a prefix (such as '__unit').
     *        For example: 
     *        1. Measure will be represented as 2 fields: value & unit
     *        Well, that's the only example for now.
     *        TODO: Do the same with Date
     * @param InputConverter $inputConverter (optional) The input converter to use. If not
     *        provided, we will use the timezone and the locale of the current user.
     */
    public function getAttributes($dateTime=false, $expanded=true, $inputConverter=null) {
        if(!$inputConverter){
            $user = Transaction::getInstance()->getUser();
            $inputConverter = new InputConverter($user->getTimezone(), $user->getLocale());        
        }
        $map = array();
<?php
  foreach ($descriptor->xml->field as $field) {
      $value = '$this->' . $field["name"];
      $inputConverterMethodCall = null;
      $dateTimeInputConverterMethodCall = null;
      $expandedInputConverterMethodCall = null;
      $type = $field['type'];
      $fieldConstant = 'self::' . $descriptor->fieldConstant($field);
      if ($field['unit']) {
          $inputConverterMethodCall = 'setDouble($map, ' . $fieldConstant . ', $this->' . $descriptor->getterName($field) . '())';
          $expandedInputConverterMethodCall = 'setMeasure($map, ' . $fieldConstant . ', $this->' . $descriptor->unitGetterName($field) . '())';
      }
      else if ($type == 'String') {
          $inputConverterMethodCall = 'setString($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == 'Boolean') {
          $inputConverterMethodCall = 'setBoolean($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == 'Date') {
          $inputConverterMethodCall = 'setDate($map, ' . $fieldConstant . ', ' . $value . ')';
          $dateTimeInputConverterMethodCall = 'setDateTime($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == 'time') {
          $inputConverterMethodCall = 'setTime($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == 'id') {
          $inputConverterMethodCall = 'setId($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == "long") {
          $inputConverterMethodCall = 'setLong($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == "double") {
          $inputConverterMethodCall = 'setDouble($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == "GeomPolygon") {
          $inputConverterMethodCall = 'setPolygon($map, ' . $fieldConstant . ', ' . $value . ')';
      }
      else if ($type == "GeomPoint") {
          $inputConverterMethodCall = 'setPoint($map, ' . $fieldConstant . ',' . $value . ')';
      }
      else {
          throw new IllegalStateException("Unsupported type: $type");
      }
      
      if ($dateTimeInputConverterMethodCall) {
?>
        if ($dateTime) {
            $inputConverter-><?php echo $dateTimeInputConverterMethodCall ?>;
        }
        else {
            $inputConverter-><?php echo $inputConverterMethodCall ?>;
        }
<?php
      }
      else if ($expandedInputConverterMethodCall) {
?>
        if ($expanded) {
            $inputConverter-><?php echo $expandedInputConverterMethodCall ?>;
        }
        else {
            $inputConverter-><?php echo $inputConverterMethodCall ?>;
        }
<?php
      }
      else {
?>
        $inputConverter-><?php echo $inputConverterMethodCall ?>;
<?php
      }
  }
?>
        return $map;
    }

    /**
     * Populate this bean with values of the the given map.
     *
     * @param Array $map
     * @param String $prefix (optional)
     * @param InputConverter $inputConverter (optional) The input converter to use. If not
     * provided, we will use the timezone and the locale of the current user.
     */
    public function setAttributes($map, $prefix='', $inputConverter=null) {
        if(!$inputConverter){
            $user = Transaction::getInstance()->getUser();
            $inputConverter = new InputConverter($user->getTimezone(), $user->getLocale());
        }
<?php
  foreach ($descriptor->xml->field as $field) {
      $constantName = 'self::' . $descriptor->fieldConstant($field);
      $key = '$prefix . ' . $constantName;
      $constant = "\$map[\$prefix . " . $constantName . "]";
      $measureConstant = null;
      $converterMethodCall = null;
      $measureConverterMethodCall = null;
      $setterName = $descriptor->setterName($field);
      $measureSetterName = null;
      $issetCondition = "isset($constant)";
      $type = $field['type'];
      if ($type == 'id') {
          $converterMethodCall = 'getId($map, ' . $key . ')';
      }
      else if ($type == 'long') {
          $converterMethodCall = 'getLong($map, ' . $key . ')';
      }
      else if ($type == 'double') {
          $converterMethodCall = 'getDouble($map, ' . $key . ')';
      }
      else if ($type == 'GeomPolygon') {
          $converterMethodCall = 'getPolygon($map, ' . $key . ')';
      }
      else if ($type == 'GeomPoint') { 
          $issetCondition = "isset(\$map[\$prefix . " . $constantName . " . \"_X\"]) && isset(\$map[\$prefix . " . $constantName . " . \"_Y\"])";
          $converterMethodCall = 'getPoint($map, ' . $key . ')';
      }
      else if ($type == 'Date') {
          $converterMethodCall = 'getDate($map, ' . $key . ')';
          $parsedConstant = "\$converter->parseDate($constant)";
      }
      else if (strtolower($type) == 'time') {
          $parsedConstant = "\$converter->parseTime($constant)";
      } 
      else {
          $parsedConstant = $constant;
      }

      if ($field['unit']) {
          $measureConstant = "\$map[\$prefix . " . $constantName . " . '__unit']";
          $measureConverterMethodCall = 'getMeasure($map, ' . $key . ')';
          $measureSetterName = $descriptor->unitSetterName($field);
      }

      if ($converterMethodCall) {
          $fieldValue = '$inputConverter->' . $converterMethodCall;
      }
      else {
          $fieldValue = $parsedConstant;
      }
?>

        if (<?php echo $issetCondition ?>) {
<?php if ($measureConverterMethodCall) {?>
            if (isset(<?php echo $measureConstant?>)) {
                $this-><?php echo $measureSetterName?>($inputConverter-><?php echo $measureConverterMethodCall?>);
            } else {
                $this-><?php echo $setterName?>(<?php echo $fieldValue?>);
            }
<?php } else {?>
            $this-><?php echo $setterName?>(<?php echo $fieldValue?>);
<?php }?>
        }
<?php
  }
?>
    }

    /**
     * Serialize the content of the bean. For debug and logging purposes.
     *
     * @return String 
     */
    public function __toString() {
        $format = Formatter::getInstance();
        return ''
<?php
  $len = count($descriptor->xml->field);
  $i = 0;
  $semiColon = '';
  foreach ($descriptor->xml->field as $field) {
      $fieldName = $field['name'];
      $getterName = $descriptor->getterName($field);
      $q = ($field['type'] == 'String') ? '"' : '';
      $valueExpression = '$this->' . $getterName . '()';
      if (($field['type'] == 'Date')) {
          $valueExpression = '$format->dateTime(' . $valueExpression . ')';
      }
      if ($field['type'] == 'time') {
          $valueExpression = '$format->secondsToTime(' . $valueExpression . ')';
      }
      // Put semicolon only after the last line
      if ($i == $len-1) {
          $semiColon = ';';
      }
      $i++;
?>
            . '<?php echo $fieldName ?>=<?php echo $q ?>' . <?php echo $valueExpression ?> . '<?php echo $q ?>; '<?php echo $semiColon ?> 
<?php
  }
?>
    }

    /**
     * Get the list of column names of the table represented by this bean.
     *
     * @return Array of String
     */
    public function getColumnNames() {
        return self::$ALL;
    }

    /**
     * Check whether this bean represents a record that already exists in the
     * database or not. This is determined by the value of the primary key.
     *
     * @return boolean true if the record does not exist in the database (i.e:
     *         its ID is not a positive number), otherwise false. 
     */
    public function isNew() {
        return $this->getId() <= 0;
    }
}